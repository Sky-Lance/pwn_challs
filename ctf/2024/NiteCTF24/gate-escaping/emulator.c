/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>

typedef struct VM_Struct_
{
  uint8_t reg1;
  uint8_t reg2;
  uint8_t reg3;
  uint8_t reg4;
  uint8_t eflags;
  uint8_t pc;
  char prompt[64];
  char pad2[183];
  char sus_ptr[9];
  uint8_t mem_buff[128];
  char extra[2];
  int64_t canary;
}VM_Struct;


char aChooseYourPath[256] =
{
  'c',
  'h',
  'o',
  'o',
  's',
  'e',
  ' ',
  'y',
  'o',
  'u',
  'r',
  ' ',
  'p',
  'a',
  't',
  'h',
  ' ',
  '(',
  '0',
  '-',
  '3',
  ')',
  ':',
  ' ',
  't',
  'h',
  'e',
  'r',
  'e',
  ' ',
  'w',
  'a',
  's',
  ' ',
  'a',
  ' ',
  'g',
  'a',
  't',
  'e',
  ' ',
  't',
  'h',
  'a',
  't',
  ' ',
  'g',
  'r',
  'a',
  'n',
  't',
  's',
  ' ',
  'a',
  'l',
  'l',
  ' ',
  'w',
  'i',
  's',
  'h',
  'e',
  's',
  '\n',
  'a',
  ' ',
  'g',
  'a',
  't',
  'e',
  ' ',
  'a',
  's',
  'k',
  's',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  'y',
  'o',
  'u',
  'r',
  ' ',
  'w',
  'i',
  's',
  'h',
  'e',
  's',
  ':',
  ' ',
  's',
  'a',
  'd',
  'l',
  'y',
  ' ',
  't',
  'h',
  'e',
  ' ',
  'g',
  'a',
  't',
  'e',
  ' ',
  'i',
  's',
  ' ',
  'a',
  'l',
  'l',
  ' ',
  'l',
  'o',
  's',
  't',
  ' ',
  'i',
  'n',
  ' ',
  't',
  'h',
  'e',
  ' ',
  'p',
  'a',
  's',
  't',
  '\n',
  'f',
  'o',
  'r',
  ' ',
  'n',
  'o',
  'w',
  ' ',
  'w',
  'e',
  ' ',
  'e',
  'x',
  'i',
  't',
  '.',
  '.',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
};
char VM_memory[128] =
{
  '(',
  '\xE1',
  '\x01',
  '(',
  '\xE2',
  '\0',
  '(',
  '\xE3',
  '\x18',
  '\xFF',
  '.',
  '(',
  '\xE1',
  '\0',
  '(',
  '\xE2',
  '\x98',
  '(',
  '\xE3',
  '\x02',
  '\xFF',
  '-',
  '\xDD',
  '\xE1',
  '\x98',
  '(',
  '\xE2',
  '\x19',
  '^',
  '\xE1',
  '\xE2',
  '(',
  '\xE2',
  '(',
  '0',
  '\xE1',
  '\xE2',
  '+',
  '\0',
  '\xE1',
  '(',
  '\xE1',
  '\x01',
  '(',
  '\xE2',
  '\x18',
  '(',
  '\xE3',
  '(',
  '\xFF',
  '.',
  '+',
  '\0',
  '\xE4',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '(',
  '\xE1',
  '\x01',
  '(',
  '\xE2',
  '@',
  '(',
  '\xE3',
  '\x1D',
  '\xFF',
  '.',
  '(',
  '\xE1',
  '\0',
  '(',
  '\xE2',
  '\xA0',
  '(',
  '\xE3',
  '`',
  '\xFF',
  '-',
  '+',
  '\0',
  '\xE4',
  '(',
  '\xE1',
  '\x01',
  '(',
  '\xE2',
  ']',
  '(',
  '\xE3',
  '\'',
  '\xFF',
  '.',
  '+',
  '\0',
  '\xE4',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '\x91',
  '(',
  '\xE1',
  '\x01',
  '(',
  '\xE2',
  '\x84',
  '(',
  '\xE3',
  '\x13',
  '\xFF',
  '.',
  '\xFF',
  '%'
}; 

int64_t exit_function()
{
   exit(0);
}


int64_t assign_register(VM_Struct *VM, uint8_t a2, char a3)
{
  int64_t result; 

  if ( a2 == 228 )
  {
    result = (int64_t)VM;
    printf("reg4 = %d\n", a3);
    VM->reg4 = a3;
  }
  else
  {
    if ( a2 <= 0xE4u )
    {
      if ( a2 == 227 )
      {
        printf("reg3 = %d\n", a3);
        result = (int64_t)VM;
        VM->reg3 = a3;
        return result;
      }

      if ( a2 <= 0xE3u )
      {
        if ( a2 == 225 )
        {
          printf("reg1 = %d\n", a3);
          result = (int64_t)VM;
          VM->reg1 = a3;
          return result;
        }

        if ( a2 == 226 )
        {
          printf("reg2 = %d\n", a3);
          result = (int64_t)VM;
          VM->reg2 = a3;
          return result;
        }
      }
    }

    return exit_function();
  }

  return result;
}



int64_t pick_register(VM_Struct *VM, uint8_t opcode)
{
  if ( opcode == 228 )
  {
    return VM->reg4;
  }

  if ( opcode <= 0xE4u )
  {
    if ( opcode == 227 )
    {
      return VM->reg3;
    }

    if ( opcode <= 0xE3u )
    {
      if ( opcode == 225 )
      {
        return VM->reg1;
      }

      if ( opcode == 226 )
      {
        return VM->reg2;
      }
    }
  }

  return exit_function();
}



char check_eflags(VM_Struct *a1, char a2)
{
  char result; 

  switch ( a2 )
  {
    case 0:
      printf("JMP\n");
      result = 1;
      break;

    case 1:
      printf("Jz\n");
      result = (a1->eflags & 2) != 0;
      break;

    case 2:
      printf("JNZ\n");
      result = (a1->eflags & 4) != 0;
      break;

    case 3:
      printf("JG\n");
      result = (a1->eflags & 8) != 0;
      break;

    case 4:
      printf("JL\n");
      result = (a1->eflags & 0x10) != 0;
      break;

    case 5:
      printf("TEST !OP1 && !OP2\n");
      result = (a1->eflags & 0x20) != 0;
      break;

    default:
      result = exit_function();
      break;
  }

  return result;
}


int64_t WRITE_PROMPT(VM_Struct *a1, uint8_t operand_2, char val)
{
  int64_t result; 

  result = operand_2;

  printf("VM->prompt[%d] = %d (%c)\n", operand_2, val, val);
  a1->prompt[operand_2] = val;
  return result;
}


int64_t index_VM(VM_Struct *a1, uint8_t a2)
{
  printf("return VM->prompt[%d] = %d\n", a2, a1->prompt[a2]);
  return (uint8_t)a1->prompt[a2];
}


int64_t index_VM_mem(VM_Struct *VM, uint8_t a2)
{
  printf("return &VM->prompt[%d] = %p\n", a2, (int64_t)&VM->prompt[a2]);
  return (int64_t)&VM->prompt[a2];
}


int64_t CMP(VM_Struct *VM, uint8_t operand_1, uint8_t operand_2)
{
  int64_t result; 

  VM->eflags = 0;
  if ( operand_1 == operand_2 )
  {
    printf("operand_1 == operand_2\n");
    VM->eflags |= 2u;
  }

  if ( operand_1 > operand_2 )
  {
    printf("operand_1 > operand_2\n");
    VM->eflags |= 8u;
  }

  if ( operand_1 < operand_2 )
  {
    printf("operand_1 < operand_2\n");
    VM->eflags |= 0x10u;
  }

  result = operand_1;
  if ( operand_1 != operand_2 )
  {
    printf("operand_1 != operand_2\n");
    result = (int64_t)VM;
    VM->eflags |= 4u;
  }

  if ( !operand_1 && !operand_2 )
  {
    printf("!operand_1 && !operand_2\n");
    result = (int64_t)VM;
    VM->eflags |= 0x20u;
  }

  return result;
}


char JUMP(VM_Struct *VM, char operand, uint8_t val)
{
  char result; 
  uint8_t new_pc; 

  result = check_eflags(VM, operand);
  if ( result )
  {
    new_pc = pick_register(VM, val);
    result = (char)VM;
    VM->pc = new_pc;
  }

  return result;
}


int64_t VM_open(VM_Struct *a1)
{
  uint8_t v2; 
  char v3; 
  int64_t *filename; 

  v2 = pick_register(a1, 0xE1u);
  filename = index_VM_mem(a1, v2);

  printf("open(%s, 0)\n", filename);
  v3 = open(filename, 0LL);
  return assign_register(a1, 0xE1u, v3);
}


int64_t VM_read(VM_Struct *a1)
{
  uint8_t v2; 
  uint8_t v3; 
  uint8_t v4; 
  char v5; 
  int64_t* v6; 

  v2 = pick_register(a1, 0xE1u);
  v3 = pick_register(a1, 0xE2u);
  v6 = index_VM_mem(a1, v3);
  v4 = pick_register(a1, 0xE3u);

  printf("read(%d, %p, %d)\n", v2, v6, v4);
  v5 = read(v2, v6, v4);
  return assign_register(a1, 0xE1u, v5);
}


int64_t VM_write(VM_Struct *VM)
{
  uint8_t fd; 
  uint8_t index; 
  uint8_t count; 
  char num_bytes_written; 
  int64_t *buffer; 

  fd = pick_register(VM, 225LL);
  index = pick_register(VM, 226LL);
  buffer = index_VM_mem(VM, index);
  count = pick_register(VM, 227LL);

  printf("write(%d, %p, %d)\n", fd, buffer, count);
  num_bytes_written = write(fd, buffer, count);
  return assign_register(VM, 0xE1u, num_bytes_written);
}



int64_t EXIT_WITH_CODE(VM_Struct *a1)
{
  uint8_t code; 

  code = pick_register(a1, 0xE1u);

  printf("exit(%d)\n", code);
  exit(code);
}


int64_t CASE_LOAD_MEM(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;

  return assign_register(VM, operand, VM->mem_buff[v2]);
}


int64_t CASE_ASSIGN_REG(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand; 
  char val; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  val = index_VM(VM, VM->mem_buff[v2]);
  return assign_register(VM, operand, val);
}



int64_t CASE_STORE(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val = pick_register(VM, operand_1);
  return WRITE_PROMPT(VM, operand_2, val);
}


int64_t CASE_CMP(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  uint8_t val1; 
  uint8_t val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);
  return CMP(VM, val1, val2);
}


char CASE_JUMP(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  char operand; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  return JUMP(VM, operand, VM->mem_buff[v2]);
}


void CASE_NOP()
{
  printf("NOP\n");
  return;
}


int64_t CASE_CALL_SYSCALL(VM_Struct *VM)
{
  int8_t pc; 
  int opcode; 

  pc = VM->pc;
  VM->pc = pc + 1;
  opcode = VM->mem_buff[pc];

  if ( opcode == 46 )
  {
    return VM_write(VM);
  }

  if ( opcode > 46 )
  {
    return exit_function();
  }

  switch ( opcode )
  {
    case '-':
      return VM_read(VM);

    case '#':
      return VM_open(VM);

    case '%':
      return EXIT_WITH_CODE(VM);

    default:
      return exit_function();
  }
}



int64_t CASE_MOV_REG(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  pick_register(VM, operand_1);
  val = pick_register(VM, operand_2);

  return assign_register(VM, operand_1, val);
}


int64_t CASE_ADD(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("ADD: %d + %d\n", val1, val2);
  return assign_register(VM, operand_1, val1 + val2);
}


int64_t CASE_SUBTRACT(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("SUBTRACT: %d - %d\n", val1, val2);
  return assign_register(VM, operand_1, val1 - val2);
}


int64_t CASE_MULTIPLY(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("MULTIPLY: %d * %d\n", val1, val2);
  return assign_register(VM, operand_1, val2 * val1);
}


int64_t CASE_XOR(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("XOR: %d ^ %d\n", val1, val2);
  return assign_register(VM, operand_1, val2 ^ val1);
}


int64_t CASE_RIGHT_SHIFT(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  uint8_t val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("RIGHT_SHIFT: %d >> %d\n", val1, val2);
  return assign_register(VM, operand_1, (int)val1 >> val2);
}


int64_t CASE_LEFT_SHIFT(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  uint8_t val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("LEFT_SHIFT: %d << %d\n", val1, val2);
  return assign_register(VM, operand_1, val1 << val2);
}


int64_t CASE_NOT(VM_Struct *VM)
{
  int8_t pc; 
  uint8_t operand; 
  uint8_t val; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand = VM->mem_buff[pc];
  val = pick_register(VM, operand);

  printf("NOT: ~%d\n", val);
  return assign_register(VM, operand, ~(val % 0xFFu));
}


int64_t CASE_ROTATE_RIGHT(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  uint8_t val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2) & 7;

  printf("ROTATE_RIGHT: %d >> %d | %d << %d\n", val1, val2, val1, 8 - val2);
  return assign_register(VM, operand_1, (uint8_t)((int)val1 >> val2) | (uint8_t)(val1 << (8 - val2)));
}


int64_t CASE_ROTATE_LEFT(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  uint8_t v6; 
  char v7; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  v6 = pick_register(VM, operand_1);
  v7 = pick_register(VM, operand_2) & 7;

  printf("ROTATE_LEFT: %d << %d | %d >> %d\n", v6, v7, v6, 8 - v7);
  return assign_register(VM, operand_1, (uint8_t)(v6 << v7) | (uint8_t)((int)v6 >> (8 - v7)));
}


int64_t CASE_NOR(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("NOR: ~(%d | %d)\n", val2, val1);
  return assign_register(VM, operand_1, ~(val2 | val1));
}


int64_t CASE_NAND(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("NAND: ~(%d & %d)\n", val2, val1);
  return assign_register(VM, operand_1, ~(val2 & val1));
}


int64_t CASE_OR(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("OR: %d | %d\n", val2, val1);
  return assign_register(VM, operand_1, val2 | val1);
}


int64_t CASE_AND(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  uint8_t operand_1; 
  uint8_t operand_2; 
  char val1; 
  char val2; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  operand_2 = VM->mem_buff[v2];
  val1 = pick_register(VM, operand_1);
  val2 = pick_register(VM, operand_2);

  printf("AND: %d & %d\n", val2, val1);
  return assign_register(VM, operand_1, val2 & val1);
}


int64_t CASE_LOAD_ADDR(VM_Struct *VM)
{
  int8_t pc; 
  int8_t v2; 
  char memory_addr_; 
  uint8_t operand_1; 
  char *memory_addr; 

  pc = VM->pc;
  VM->pc = pc + 1;
  operand_1 = VM->mem_buff[pc];
  v2 = VM->pc;
  VM->pc = v2 + 1;
  memory_addr = (char *)index_VM_mem(VM, VM->mem_buff[v2]);
  memory_addr_ = atoi(memory_addr);

  printf("LOAD_ADDR: %d\n", memory_addr_);
  return assign_register(VM, operand_1, memory_addr_);
}


void process_instruction(VM_Struct *VM, uint8_t opcode)
{
  if ( opcode == 255 )
  {
    CASE_CALL_SYSCALL(VM);
    return;
  }

  if ( opcode == 221 )
  {
    CASE_LOAD_ADDR(VM);
    return;
  }

  if ( opcode > 0xDDu )
  {
    goto EXIT_CASE;
  }

  if ( opcode == 191 )
  {
    CASE_AND(VM);
    return;
  }

  if ( opcode > 0xBFu )
  {
    goto EXIT_CASE;
  }

  if ( opcode == 185 )
  {
    CASE_OR(VM);
    return;
  }

  if ( opcode > 0xB9u )
  {
    goto EXIT_CASE;
  }

  if ( opcode > 0x98u )
  {
    if ( opcode == 170 )
    {
      CASE_MOV_REG(VM);
      return;
    }

    goto EXIT_CASE;
  }

  if ( opcode < 0x20u )
  {
EXIT_CASE:
    exit_function();
    return;
  }

  switch ( opcode )
  {
    case 0x20u:
      CASE_SUBTRACT(VM);
      break;

    case 0x22u:
      CASE_CMP(VM);
      break;

    case 0x24u:
      CASE_STORE(VM);
      break;

    case 0x26u:
      CASE_NOR(VM);
      break;

    case 0x28u:
      CASE_LOAD_MEM(VM);
      break;

    case 0x2Au:
      CASE_ASSIGN_REG(VM);
      break;

    case 0x2Bu:
      CASE_JUMP(VM);
      break;

    case 0x2Cu:
      CASE_NAND(VM);
      break;

    case 0x30u:
      CASE_ADD(VM);
      break;

    case 0x5Au:
      CASE_LEFT_SHIFT(VM);
      break;

    case 0x5Eu:
      CASE_MULTIPLY(VM);
      break;

    case 0x67u:
      CASE_RIGHT_SHIFT(VM);
      break;

    case 0x72u:
      CASE_ROTATE_RIGHT(VM);
      break;

    case 0x8Fu:
      CASE_ROTATE_LEFT(VM);
      break;

    case 0x91u:
      CASE_NOP();
      break;

    case 0x98u:
      CASE_NOT(VM);
      break;

    default:
      goto EXIT_CASE;
  }
}



void VM_Init(VM_Struct *VM)
{
  int8_t pc; 

  while ( 1 )
  {
    pc = VM->pc;
    VM->pc = pc + 1;
    process_instruction(VM, (uint8_t)VM->mem_buff[pc]);
  }
}






int main(int a1, char **a2, char **a3)
{
  VM_Struct s; 

  memset(&s, 0, 390uLL);
  *(int64_t *)s.mem_buff = *(int64_t *)VM_memory;
  *(int64_t *)&s.mem_buff[8] = *(int64_t *)&VM_memory[8];
  *(int64_t *)&s.mem_buff[16] = *(int64_t *)&VM_memory[16];
  *(int64_t *)&s.mem_buff[24] = *(int64_t *)&VM_memory[24];
  *(int64_t *)&s.mem_buff[32] = *(int64_t *)&VM_memory[32];
  *(int64_t *)&s.mem_buff[40] = *(int64_t *)&VM_memory[40];
  *(int64_t *)&s.mem_buff[48] = *(int64_t *)&VM_memory[48];
  *(int64_t *)&s.mem_buff[56] = *(int64_t *)&VM_memory[56];
  *(int64_t *)&s.mem_buff[64] = *(int64_t *)&VM_memory[64];
  *(int64_t *)&s.mem_buff[72] = *(int64_t *)&VM_memory[72];
  *(int64_t *)&s.mem_buff[80] = *(int64_t *)&VM_memory[80];
  *(int64_t *)&s.mem_buff[88] = *(int64_t *)&VM_memory[88];
  *(int64_t *)&s.mem_buff[96] = *(int64_t *)&VM_memory[96];
  *(int64_t *)&s.mem_buff[104] = *(int64_t *)&VM_memory[104];
  *(int64_t *)&s.mem_buff[112] = *(int64_t *)&VM_memory[112];
  *(int64_t *)&s.mem_buff[120] = *(int64_t *)&VM_memory[120];
  *(int64_t *)s.prompt = *(int64_t *)aChooseYourPath;
  *(int64_t *)s.sus_ptr = *(int64_t *)&aChooseYourPath[247];
  memcpy(
    &s.prompt[2],
    &aChooseYourPath[-(s.prompt - &s.prompt[2])],
    8LL * ((((unsigned int)(s.prompt - &s.prompt[2]) + 255) & -8u) >> 3));
  VM_Init(&s);
}